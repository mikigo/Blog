import{_ as s,c as t,R as e,o as i}from"./chunks/framework.CpY5Ih_Y.js";const n="/blog/avocado_assets/3.png",l="/blog/avocado_assets/1.png",o="/blog/avocado_assets/2.png",h="/blog/avocado_assets/4.png",y=JSON.parse('{"title":"Avocado和YouQu对比调研报告","description":"","frontmatter":{"Author":"mikigo"},"headers":[],"relativePath":"技术文档/技术调研/《Avocado和YouQu对比》调研报告.md","filePath":"技术文档/技术调研/《Avocado和YouQu对比》调研报告.md","lastUpdated":1736881163000}'),p={name:"技术文档/技术调研/《Avocado和YouQu对比》调研报告.md"};function d(r,a,c,u,k,g){return i(),t("div",null,a[0]||(a[0]=[e('<h1 id="avocado和youqu对比调研报告" tabindex="-1">Avocado和YouQu对比调研报告 <a class="header-anchor" href="#avocado和youqu对比调研报告" aria-label="Permalink to &quot;Avocado和YouQu对比调研报告&quot;">​</a></h1><p>Avocado 是一个基于 Linux 的自动化测试框架，使用 Python 语言编写构建，具有许多特色功能；YouQu 也是基于 Linux 的自动化测试框架，同样也是使用 Python 语言编写构建。</p><p>本文主要探寻 Avocado 引以为傲的特色功能，与 YouQu 框架进行对比，看看哪个框架更加适合现代化的自动化测试。</p><p>以下将从几个方面分别对各功能进行对比：</p><h2 id="驱动方式" tabindex="-1">驱动方式 <a class="header-anchor" href="#驱动方式" aria-label="Permalink to &quot;驱动方式&quot;">​</a></h2><h3 id="avocado" tabindex="-1">Avocado <a class="header-anchor" href="#avocado" aria-label="Permalink to &quot;Avocado&quot;">​</a></h3><p>Avocado 使用命令行方式驱动，使用子命令 <code>run</code> 执行用例；</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">avocado</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span></span></code></pre></div><p>远程执行也有插件支持。</p><h3 id="youqu" tabindex="-1">YouQu <a class="header-anchor" href="#youqu" aria-label="Permalink to &quot;YouQu&quot;">​</a></h3><p>这点和 YouQu 不谋而合，YouQu 也是命令行方式驱动，本机运行的子命令也是 <code>run</code> ；</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">youqu</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> manage.py</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span></span></code></pre></div><p>这里申明，YouQu 在设计时绝对没有参考 Avocado ，纯属巧合，只能说英雄所见略同。</p><p>YouQu 除了 <code>run</code> 子命令，还支持其他的子命令，如： <code>remote, pmsctl, csvctl, startapp</code> ；</p><p>详细用法情况查看：<a href="http://youqu.uniontech.com/%E6%A1%86%E6%9E%B6%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/%E6%89%A7%E8%A1%8C%E7%AE%A1%E7%90%86%E5%99%A8/" target="_blank" rel="noreferrer">http://youqu.uniontech.com/框架功能介绍/执行管理器/</a></p><h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h3><p>驱动方式都采用了类似的功能设计，都支持自定义扩展驱动功能。</p><h2 id="多种格式的测试报告" tabindex="-1">多种格式的测试报告 <a class="header-anchor" href="#多种格式的测试报告" aria-label="Permalink to &quot;多种格式的测试报告&quot;">​</a></h2><h3 id="avocado-1" tabindex="-1">Avocado <a class="header-anchor" href="#avocado-1" aria-label="Permalink to &quot;Avocado&quot;">​</a></h3><p>Avocado 默认支持 XML、JSON 格式的测试报告，至于 HTML 格式的测试报告需要安装插件 <code>avocado-framework-plugin-result-html</code>；</p><p>Avocado 的 HTML 报告是这样的：</p><p><img src="'+n+'" alt=""></p><h3 id="youqu-1" tabindex="-1">YouQu <a class="header-anchor" href="#youqu-1" aria-label="Permalink to &quot;YouQu&quot;">​</a></h3><p>YouQu 默认支持 XML、JSON、HTML格式的测试报告。</p><p>YouQu 的 HTML 报告是这样的：</p><p><img src="'+l+'" alt=""></p><p><img src="'+o+'" alt=""></p><h3 id="小结-1" tabindex="-1">小结 <a class="header-anchor" href="#小结-1" aria-label="Permalink to &quot;小结&quot;">​</a></h3><p>Avocado 官方是这样评价它的 HTML 报告的：</p><div class="tip custom-block"><p class="custom-block-title">截图自官网</p><p><img src="'+h+`" alt=""></p></div><p>。。😅</p><p>我只能说 Avocado 这个报告还有很大的进步空间，尊重并祝福。</p><p>YouQu 的测试报告除了 UI 界面好看、信息展示全，还加入了用例失败录屏、失败截图、用例执行日志等等，建议 Avocado 尽快使用 YouQu 的测试报告插件。</p><h2 id="收集系统数据" tabindex="-1">收集系统数据 <a class="header-anchor" href="#收集系统数据" aria-label="Permalink to &quot;收集系统数据&quot;">​</a></h2><p>Avocado 自带一个 sysinfo 插件，能自动收集一些系统运行数据，如：cpuinfo、meminfo等；</p><p>YouQu 自带一个 <code>--top</code> 参数，可以自动收集系统运行时的 top 命令的数据；</p><p>这个功能可以辅助做测试用例失败分析，但是个人认为自动化框架收集系统数据还是有局限，而使用 Prometheus、Zabbix、Grafana 等专业的监控工具更好。</p><p>所以，此功能我个人认为，聊胜于无吧，就不做展开分析了。</p><h2 id="批量运行用例" tabindex="-1">批量运行用例 <a class="header-anchor" href="#批量运行用例" aria-label="Permalink to &quot;批量运行用例&quot;">​</a></h2><h3 id="avocado-2" tabindex="-1">Avocado <a class="header-anchor" href="#avocado-2" aria-label="Permalink to &quot;Avocado&quot;">​</a></h3><p>Avocado 提供了通过标签筛选测试用例执行的功能；</p><h4 id="用例标签" tabindex="-1">用例标签 <a class="header-anchor" href="#用例标签" aria-label="Permalink to &quot;用例标签&quot;">​</a></h4><p>用例标签的标注方式是在用例代码中<code>用例类说明</code>或<code>用例函数说明</code> 里面来标注，必须使用 <code>:avocado: tags=</code> 这样的范式写标签。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FastTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    :avocado: tags=fast</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test_fast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        :avocado: tags=net</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;&quot;&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test_fast_other</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        :avocado: tags=net</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;&quot;&quot;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SlowTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    :avocado: tags=slow,disk</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test_slow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        time.sleep(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SlowUnsafeTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    :avocado: tags=slow,disk,unsafe</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test_slow_unsafe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        time.sleep(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h4 id="筛选用例执行" tabindex="-1">筛选用例执行 <a class="header-anchor" href="#筛选用例执行" aria-label="Permalink to &quot;筛选用例执行&quot;">​</a></h4><p>使用 <code>--filter-by-tags</code> 参数指定标签的名称，支持多种逻辑组合；</p><ul><li>执行包含某一个标签的用例： <code>--filter-by-tags=net</code></li><li>执行包含不某一个标签的用例：<code>--filter-by-tags=-net</code></li><li>执行同时包含多个标签的用例：<code>--filter-by-tags=disk,slow,unsafe</code></li><li>执行包含 disk 标签或包含 net 标签的用例：<code>--filter-by-tags=disk --filter-by-tags=net</code></li></ul><h3 id="youqu-2" tabindex="-1">YouQu <a class="header-anchor" href="#youqu-2" aria-label="Permalink to &quot;YouQu&quot;">​</a></h3><h4 id="用例标签-1" tabindex="-1">用例标签 <a class="header-anchor" href="#用例标签-1" aria-label="Permalink to &quot;用例标签&quot;">​</a></h4><p>YouQu的用例标签是在一个 CSV 文件里面去写，方便维护者使用 Excel 打开进行编辑：</p><p>CSV 文件标签示例：</p><table><thead><tr><th style="text-align:center;">脚本ID</th><th style="text-align:center;">PMS用例ID</th><th style="text-align:center;">用例级别</th><th style="text-align:center;">用例类型</th><th style="text-align:center;">设备类型</th><th style="text-align:center;">一二级bug自动化</th><th style="text-align:center;">上线对象</th><th style="text-align:center;">跳过原因</th><th style="text-align:center;">确认修复</th><th style="text-align:center;">废弃用例</th><th style="text-align:left;">...</th></tr></thead><tbody><tr><td style="text-align:center;">679537</td><td style="text-align:center;">679537</td><td style="text-align:center;">L1</td><td style="text-align:center;">FUNC</td><td style="text-align:center;">PPL</td><td style="text-align:center;">BUG</td><td style="text-align:center;">CICD</td><td style="text-align:center;">skip-XXX</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:left;"></td></tr></tbody></table><p>标签支持无限扩展，标签支持自动生成和自动维护，维护起来非常方便，不需要到茫茫多的 py 用例脚本中去改标签，使用 Excel 打开就能快速的维护标签 。</p><h4 id="筛选用例执行-1" tabindex="-1">筛选用例执行 <a class="header-anchor" href="#筛选用例执行-1" aria-label="Permalink to &quot;筛选用例执行&quot;">​</a></h4><p>通过参数 <code>-t 或 --tags</code> 指定不同的标签进行用例筛选执行，而且标签支持使用 <code>and/or/not</code> 逻辑进行组合，比如：<code>-t &#39;L1 and FUNC&#39;</code> 表示执行带有 L1 且 带有 FUNC 标签的用例，使用非常符合语义对吧。</p><p>而且还支持通过指定关键词进行用例筛选，使用参数 <code>-k 或 --keywords</code> 指定关键词，关键词也支持使用 <code>and/or/not</code> 逻辑组合，关键词有很多，比如：py 文件的名称、用例类名称、用例函数名称、名称中的部分字符等等都是关键词。</p><p>而且的而且，标签和关键词两个参数可以同时使用，可以组合出任意的用例集合，只有想不到没有办不到。</p><h3 id="小结-2" tabindex="-1">小结 <a class="header-anchor" href="#小结-2" aria-label="Permalink to &quot;小结&quot;">​</a></h3><p>Avocado 这样的标签管理方式是非常难以维护的，因为标签分布在各个脚本的注释中，如果后期要进行批量的修改，维护者将会非常痛苦而且非常耗时，你可以想象一下，在几千各 py 文件中，挨个打开修改一个注释，人都麻了。我只能说非常的 Old school。</p><p>而 Avocado 的用例筛选执行方式，官方文档用了大量的篇幅和示例来介绍其用法，基本能满足业务使用要求，但是使用比较麻烦，参数传递不够优雅。</p><p>YouQu 的用例标签化管理是独有的专利方案，所有的标签在一个 <code>CSV</code> 文件里面去维护，可维护性非常高，而且标签支持自动生成自动维护；</p><p>基于此标签化管理方案，YouQu 支持灵活的用例组织方式，而且标签参数支持使用 <code>and/or/not</code> 逻辑组合，非常符合语义，根本不需要对使用方法做大量文档说明，使用者就能立马 get 到它的用法。</p><h2 id="高级日志记录功能" tabindex="-1">高级日志记录功能 <a class="header-anchor" href="#高级日志记录功能" aria-label="Permalink to &quot;高级日志记录功能&quot;">​</a></h2><h3 id="avocado-3" tabindex="-1">Avocado <a class="header-anchor" href="#avocado-3" aria-label="Permalink to &quot;Avocado&quot;">​</a></h3><p>特点是能记录所有的日志，生成日志文件。</p><h3 id="youqu-3" tabindex="-1">YouQu <a class="header-anchor" href="#youqu-3" aria-label="Permalink to &quot;YouQu&quot;">​</a></h3><p>全自动日志系统，只需要一个装饰器，自动输出全部日志，并保存到日志文件。<a href="http://youqu.uniontech.com/%E6%A1%86%E6%9E%B6%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noreferrer">《YouQu 日志系统》</a></p><h3 id="小结-3" tabindex="-1">小结 <a class="header-anchor" href="#小结-3" aria-label="Permalink to &quot;小结&quot;">​</a></h3><p>Avocado 的日志模块看似平平无奇，实则司空见惯，而 YouQu 的日志系统，全自动输出日志系统。</p><h2 id="配置" tabindex="-1">配置 <a class="header-anchor" href="#配置" aria-label="Permalink to &quot;配置&quot;">​</a></h2><h3 id="avocado-4" tabindex="-1">Avocado <a class="header-anchor" href="#avocado-4" aria-label="Permalink to &quot;Avocado&quot;">​</a></h3><p>Avocado 存在多个配置文件：</p><ul><li><code>/etc/avocado/avocado.conf</code> 这是一个系统级别的配置文件，对所有用户生效；</li><li><code>/etc/avocado/conf.d/*.conf</code> 这个目录下也可以放配置文件，也是一个系统级别的配置文件；</li><li><code>~/.config/avocado/avocado.conf</code> 用户级别的配置文件；</li></ul><p>用户配置文件的配置项可以覆盖系统级别的配置文件的配置项。</p><p>测试执行时配置项的优先顺序：</p><p>命令行参数 &gt; 用户配置文件 &gt; 系统配置文件；</p><h3 id="youqu-4" tabindex="-1">YouQu <a class="header-anchor" href="#youqu-4" aria-label="Permalink to &quot;YouQu&quot;">​</a></h3><p>YouQu 的配置文件只有一个，<code>setting/globalconfig.ini</code> ，提供一个全局配置对象 <code>conf</code>，使用此对象可以访问全局配置里面的所有配置；</p><p>比如：</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> setting </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> conf</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">conf.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ROOT_DIR</span></span></code></pre></div><p>基于 YouQu 的子项目里面会有一个局部配置文件 <code>config.ini</code>，提供一个配置对象 <code>config</code>，使用此对象可以访问 <code>局部配置 + 全局配置</code> 的所有配置；</p><p>比如：</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> apps.autotest_dde_file_manager.config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> config</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">config.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ROOT_DIR</span></span></code></pre></div><p>局部配置的值可以覆盖全局配置值；</p><p>测试执行时配置项的优先顺序：</p><p>命令行参数 &gt; 局部配置 &gt; 全局配置；</p><h3 id="小结-4" tabindex="-1">小结 <a class="header-anchor" href="#小结-4" aria-label="Permalink to &quot;小结&quot;">​</a></h3><p>两个框架的配置体系整体设计思想是类似的。</p><p>Avocado 的系统配置可能存在多个，看似可配置项很多，实际不好管理，YouQu 的配置理念是 All in One，简洁优雅永不过时。</p><h2 id="自定义依赖项" tabindex="-1">自定义依赖项 <a class="header-anchor" href="#自定义依赖项" aria-label="Permalink to &quot;自定义依赖项&quot;">​</a></h2><h3 id="avocado-5" tabindex="-1">Avocado <a class="header-anchor" href="#avocado-5" aria-label="Permalink to &quot;Avocado&quot;">​</a></h3><p>Avocado 的依赖的概念实际上是用例前置条件（setup）的概念，简单讲就是这条用例执行之前可能需要处理以下依赖环境，比如装一些个三方包或者获取测试资源等等。</p><p>依赖项定义方式是在用例类说明里面写注释：</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> avocado </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Test</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PassTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    Example test that passes.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    :avocado: dependency={&quot;type&quot;: &quot;package&quot;, &quot;name&quot;: &quot;hello&quot;}</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span></code></pre></div><p>固定格式 <code>:avocado: dependency=</code> ，和标签管理那里一样，维护性太差。</p><h3 id="youqu-5" tabindex="-1">YouQu <a class="header-anchor" href="#youqu-5" aria-label="Permalink to &quot;YouQu&quot;">​</a></h3><p>YouQu 的前置条件处理支持了非常灵活的写法，参考 <a href="http://youqu.uniontech.com/docs/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%8A%80%E6%9C%AF/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/Pytest%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%B5%B7%E9%A3%9E.html#%E5%9B%9B%E3%80%81fixture" target="_blank" rel="noreferrer">Pytest Fixture</a> 写法，除了生孩子，你可以在前置条件里面做任何想做的事情；</p><p>除此之外，尽管 YouQu 致力于将用例需要的所有依赖项在环境部署阶段都初始化好，但 YouQu 仍然支持子项目对测试环境部署进行<a href="http://youqu.uniontech.com/%E6%A1%86%E6%9E%B6%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/#2" target="_blank" rel="noreferrer">定制依赖项</a> 。</p><h3 id="小结-5" tabindex="-1">小结 <a class="header-anchor" href="#小结-5" aria-label="Permalink to &quot;小结&quot;">​</a></h3><p>Avocado 对于依赖项的处理是用字符串硬编码，分布在各个用例脚本里面，而 YouQu 的环境依赖处理，在灵活性和易维护性上无可比拟；</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><table><thead><tr><th>对比功能点</th><th style="text-align:center;">Avocado <img width="200/"></th><th style="text-align:center;">YouQu <img width="200/"></th></tr></thead><tbody><tr><td>驱动方式</td><td style="text-align:center;">😄</td><td style="text-align:center;">😄</td></tr><tr><td>测试报告</td><td style="text-align:center;">✗</td><td style="text-align:center;">✓ 略胜三筹</td></tr><tr><td>收集系统数据</td><td style="text-align:center;">😄</td><td style="text-align:center;">😄</td></tr><tr><td>批量运行用例</td><td style="text-align:center;">✗</td><td style="text-align:center;">✓ 略胜三筹</td></tr><tr><td>高级日志记录功能</td><td style="text-align:center;">✗</td><td style="text-align:center;">✓ 略胜三筹</td></tr><tr><td>配置</td><td style="text-align:center;">😄</td><td style="text-align:center;">😄</td></tr><tr><td>自定义依赖</td><td style="text-align:center;">✗</td><td style="text-align:center;">✓ 略胜三筹</td></tr><tr><td>插件</td><td style="text-align:center;">✗</td><td style="text-align:center;">✓ 略胜三筹</td></tr></tbody></table><p>Avocado 基于 unitttest 来管理和驱动用例执行，YouQu 基于 Pytest 来管理和驱动用例执行，Pytest 比 unittest 本身具有技术优势，从技术上讲 YouQu 是天然兼容 Avocado 的用例的，反之则不然，再加上 YouQu 在此之上加入了许多自研功能，比如：用例标签化管理方案、全自动日志系统、用例失败录屏，在整体技术架构上不能说是更胜一筹，只能说是属于两个时代的产品。</p><p>Avocado 还支持一些内置插件和三方插件，但插件这块且不提 YouQu 有自己的生态插件，咱就说 Pytest 社区就有海量的<a href="https://github.com/mikigo/pytest-plugins" target="_blank" rel="noreferrer">插件</a>，Avocado 可以说完全不再一个级别，相当于是地球人遇到三体人。</p><p>Avocado 主打 Linux CLI 测试这块，底层方法模块在 Linux 内核、命令这块确有独到之处，底层方法基于 Python 与 Linux 进行交互，易于移植，但框架技术架构上没有任何优势；</p><p>YouQu 主打在 Linux 操作系统桌面应用 UI、接口自动化这块，添加一些 Linux CLI 相关底层功能很容易，在框架技术架构、 以及各功能方面几乎是<strong>全面碾压 Avocado</strong>。</p>`,106)]))}const F=s(p,[["render",d]]);export{y as __pageData,F as default};
