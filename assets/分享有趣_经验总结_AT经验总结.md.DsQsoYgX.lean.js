import{_ as i,c as a,R as n,o as l}from"./chunks/framework.CpY5Ih_Y.js";const c=JSON.parse('{"title":"AT 经验总结","description":"","frontmatter":{"Author":"mikigo、litao"},"headers":[],"relativePath":"分享有趣/经验总结/AT经验总结.md","filePath":"分享有趣/经验总结/AT经验总结.md","lastUpdated":1737267928000}'),e={name:"分享有趣/经验总结/AT经验总结.md"};function p(t,s,h,k,d,o){return l(),a("div",null,s[0]||(s[0]=[n(`<h1 id="at-经验总结" tabindex="-1">AT 经验总结 <a class="header-anchor" href="#at-经验总结" aria-label="Permalink to &quot;AT 经验总结&quot;">​</a></h1><blockquote><p>欢迎所有人提交你在自动化测试方面的优秀实践经验，以帮助大家解决可能遇到的问题。</p></blockquote><h2 id="用例调试技巧" tabindex="-1">用例调试技巧 <a class="header-anchor" href="#用例调试技巧" aria-label="Permalink to &quot;用例调试技巧&quot;">​</a></h2><h3 id="_1-日志" tabindex="-1">1. 日志 <a class="header-anchor" href="#_1-日志" aria-label="Permalink to &quot;1. 日志&quot;">​</a></h3><ul><li>一定要先看报错，看 <code>error</code> 日志，通常能明确的告诉你具体哪里代码报错；</li><li>结合报错点前面的 <code>error</code>、 <code>info</code> 和 <code>debug</code> 日志看否是正常。</li></ul><h3 id="_2-断点调试" tabindex="-1">2. 断点调试 <a class="header-anchor" href="#_2-断点调试" aria-label="Permalink to &quot;2. 断点调试&quot;">​</a></h3><ul><li>方法报错： <ul><li>在方法库中找到对应的方法，单独调用，看是否能正常执行；</li><li>通常单个方法的执行是比较简单的，如果单个方法报错，很快就能排查出问题；在方法内部打断点，使用 <code>Debug</code> 运行，看方法内部数据传递是否存在问题；</li><li>如果单个方法调用没问题，那么在用例中报错的方法前面打断点，使用 <code>Debug</code> 运行，看用例的业务逻辑和数据传递是否存在问题；</li></ul></li><li>断言报错： <ul><li>断言为数据断言，根据表达式进行断言语句进行修改；</li><li>文件生成类断言，查看是否需要加等待时间；</li><li>图像断言，在断言语句处打断点，使用 <code>Debug</code> 运行，用例运行到断言处会停止，查看此时断言的图片与用例执行的现场存在什么差异，此时也可以进行重新截图，从而替换新的图片；</li></ul></li></ul><h3 id="_3-远程执行" tabindex="-1">3. 远程执行 <a class="header-anchor" href="#_3-远程执行" aria-label="Permalink to &quot;3. 远程执行&quot;">​</a></h3><ul><li><p>远程执行指的是编辑器通过指定远程解释器执行自动化代码；</p><p>远程执行的好处是可以很方便的 <code>Debug</code> 运行，不用在测试机上打开编辑器，用例执行速度更快；</p><p>支持远程执行功能的编辑器：</p><ul><li>专业版 <code>Pycharm</code></li><li><code>VScode</code> ，需要使用插件 <code>Remote-SSH</code></li></ul></li><li><p>远程执行配置</p><p>以 <code>Pycharm</code> 为例：</p><p><code>File</code> —&gt; <code>Settings</code> —&gt; <code>Project</code> —&gt; <code>Python Interpreter</code> —&gt; <code>右边设置按钮</code> —&gt; <code>Add...</code> —&gt; <code>SSH Interpreter</code> —&gt; <code>New server configuration(填入host和username)</code> —&gt; <code>Next</code> —&gt; <code>password（测试机密码）</code> —&gt; <code>Interpreter(选择远程解释器)</code> —&gt; <code>Finish</code></p></li></ul><h3 id="_4-环境清理" tabindex="-1">4. 环境清理 <a class="header-anchor" href="#_4-环境清理" aria-label="Permalink to &quot;4. 环境清理&quot;">​</a></h3><ul><li>如果用例里面的 <code>teardown</code> 没有执行，大概率是因为 <code>setup</code> 里面代码报错，这两个是一对的，<code>setup</code> 里面报错，<code>teardown</code> 里面的代码不会执行；</li><li>目前我们已经将各应用的 <code>clean_all</code> 这个 <code>fixture</code> 改成了终结器，确保始终能执行到这步，但是用例里面的 <code>fixture</code>，还是需要我们小心处理；</li><li>要执行 <code>clean_all</code> 需要在编辑器运行参数加 <code>--clean yes</code>，写用例的时候请加上，不然你不确定用例执行之后的环境是否恢复；</li><li><code>setup</code> 可以不要，将 <code>setup</code> 放到用例里面是一种稳妥的做法，<code>teardown</code> 一定要。</li></ul><h3 id="_5-元素定位不准-坐标返回不对" tabindex="-1">5. 元素定位不准（坐标返回不对） <a class="header-anchor" href="#_5-元素定位不准-坐标返回不对" aria-label="Permalink to &quot;5. 元素定位不准（坐标返回不对）&quot;">​</a></h3><ul><li>基于 <code>UI</code> 定位的方法，可能受到窗口 ID 的变化，导致坐标返回不准，默认取最新的一个窗口用于定位，但如果实际需要定位的不是最新的窗口，那么在用例中需要重新实例化方法类对象，并在类中传入对应的窗口序号；</li><li>基于属性定位的方法，目前遇到的笔记本上，由于屏幕缩放比例为 1.25，导致坐标返回不准，我们默认使用缩放比例为 1；</li><li>基于图像定位的方法，如果当前屏幕中存在多个相同的目标元素，可能出现定位不准；支持通过参数控制，返回多个坐标；</li><li>基于 OCR 定位的方法，如果当前屏幕中存在多个相同的文字元素，可能出现定位不准；同样支持通过参数控制，返回多个坐标；</li></ul><h3 id="_6-键鼠操作不准" tabindex="-1">6. 键鼠操作不准 <a class="header-anchor" href="#_6-键鼠操作不准" aria-label="Permalink to &quot;6. 键鼠操作不准&quot;">​</a></h3><ul><li>鼠标操作不生效，比如右键、双击无响应；</li><li>键盘操作不生效，或者延迟输入，比如用例需要输入“我是中国人”，实际只输入了“我国人”；</li></ul><p>以上问题排除应用卡顿等问题，大概率是由于工具的问题，目前键鼠操作我们使用三个工具：<code>Dogtail</code> 提供的键鼠工具、<code>PyAutoGUI</code>、<code>Xdotool</code> ；</p><p>有同学可能要说为啥要用三个啊，用一个不就好了，简单讲就是各有优点各有缺点。</p><p>如果你遇到键鼠的问题，可以试试通过不同的工具操作；键盘输入延迟的问题，一般是因为输入速度太快了，系统没反应过来，常见于 <code>ARM</code> 和 <code>MIPS</code> 上，修改参数 delay_time 的值，单位为毫秒；</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># mouse_key.py</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">classmethod</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> input_message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cls, message, delay_time</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">300</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, interval</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    输入字符串</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    :param message: 输入的内容</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    :param delay_time: 延迟时间</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    :param interval:</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    :return:</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span></code></pre></div><p>如果不是方法的问题，则需要继续和开发一起排除，是否为应用接受键鼠信号处理的问题，这类情况我们也是遇到过的，具体问题具体分析。</p><p>比如影院就重写了一个右键的方法：</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># base_widget.py</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">classmethod</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> right_click</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cls, _x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, _y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    重写底层单击鼠标右键</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    解决影院右键触发release事件的问题（右键主窗口会播放视频）</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    cls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.mouse_down(_x, _y, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">button</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sleep(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    cls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.mouse_up(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">button</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h2 id="终结器" tabindex="-1">终结器 <a class="header-anchor" href="#终结器" aria-label="Permalink to &quot;终结器&quot;">​</a></h2><p>前置/后置步骤</p><p>Pytest 实现前置/后置步骤的方式有两种，yield 和终结函数；</p><p>yield 实现，yield前面为用例的前置步骤，yield 后面为用例的后置步骤。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@pytest.fixture</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> clean_env</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;setup&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    yield</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;teardown&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>终结函数实现，使用 request.addfinalizer 注册用例的后置步骤</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@pytest.fixture</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> clean_env</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(request):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> clean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;teardown&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    request.addfinalizer(clean)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;setup&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>yield的优缺点：</p><p>优点：代码简洁，直观，可使用yield在用例中获取前置步骤的返回值</p><p>缺点：若前置步骤中出现错误，则后置步骤不会执行</p><p>终结函数：</p><p>优点：前置步骤失败的话，后置步骤仍会执行且可以注册多个后置步骤（前提：需要在代码报错之前注册后置步骤），支持灵活使用后置条件</p><p>缺点：代码较为复杂，无法获取前置步骤的返回值（本人目前未实现）</p><p>总结：在前置步骤保证绝对不会出错时，使用yield更佳简便，当前置步骤易出现问题时，推荐使用终结函数。</p><p>场景：保险箱用例，前置步骤中开启保险箱，后置步骤删除保险箱。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@pytest.fixture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">scope</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;session&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">autouse</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">True</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vault_fixture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(request):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    DfmWidget.reset_vault_by_cmd()	</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 1、重置保险箱</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    DdeDockPublicWidget().close_file_manager_by_cmd() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 2、关闭文管</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    DdeDockPublicWidget().open_file_manager_in_dock_by_attr() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 3、开启文管</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vault </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DfmWidget()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vault.create_file_vault()	</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 4、创建保险箱</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> delete_vault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():	</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 8、删除保险箱的后置步骤</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        sleep(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        DdeDockPublicWidget().open_file_manager_in_dock_by_attr()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        vault </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DfmWidget()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        vault.delete_file_vault()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        DfmWidget.reset_vault_by_cmd()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        DdeDockPublicWidget().close_file_manager_by_cmd()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    request.addfinalizer(delete_vault)	</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 5、注册后置步骤</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    DdeDockPublicWidget().close_file_manager_by_cmd()	</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 6、关闭文管</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sleep(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    DdeDockPublicWidget().open_file_manager_in_dock_by_attr() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 7、开启文管</span></span></code></pre></div><p>代码按注释中的序号执行步骤：</p><ul><li>代码在步骤 1 - 4 任意位置报错，则不会执行步骤 8，因为未执行到步骤 5，步骤8还未注册；</li><li>代码在步骤 6 - 7 报错，仍会执行步骤 7，因为在步骤 5 中已经将步骤 7 注册；</li></ul><p>可以灵活注册后置步骤，能实现某个前置步骤执行之后，才会执行后置步骤。</p><h2 id="启动应用的方式" tabindex="-1">启动应用的方式 <a class="header-anchor" href="#启动应用的方式" aria-label="Permalink to &quot;启动应用的方式&quot;">​</a></h2><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># huangmingqiang@uniontech.com</span></span></code></pre></div><p>（1）命令行启动</p><p>在 AT 代码中使用命令行启动应用，举例：</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">os.popen(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;deepin-music&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>这种方式启动存在一个问题，就是当使用 ssh 远程执行用例时，<code>dogtail</code> 无法获取到元素。</p><p>（2）通过 UI 操作启动</p><p>通过任务栏、启动器、桌面等 UI 方式启动，比如双击打开、右键打开等，这种操作方式不存在 ssh 远程执行用例时 <code>dogtail</code> 无法获取到元素的问题，也更加符合用户的操作行为。</p><h2 id="文件选择框属性定位偶现无法找到" tabindex="-1">文件选择框属性定位偶现无法找到 <a class="header-anchor" href="#文件选择框属性定位偶现无法找到" aria-label="Permalink to &quot;文件选择框属性定位偶现无法找到&quot;">​</a></h2><p>文件选择框存在一个问题，在调用文件选择框时，有一定的概率出现，界面已经渲染出来了，但是属性树并没有写入，导致通过属性无法找到元素，目前也没有很好的解决方案，为了用例稳定性，文件选择框的操作建议使用 UI 或者图片定位的方式，可以通过搜索内容固定文件位置。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># litaoa@uniontech.com</span></span></code></pre></div><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">desk </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DdeDesktopPublicWidget()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 选择视频目录</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">desk.click_videos_dir_in_desktop_plugs_by_ui()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sleep(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">desk.ctrl_f()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sleep(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">desk.input_message(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;元素名称&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sleep(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">desk.enter()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sleep(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 选择第一个文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">desk.click_list_view_btn_in_desktop_plugs_by_ui()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sleep(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">desk.click_first_file_in_desktop_plugs_by_ui()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sleep(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 文管插件中点击打开</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">desk.click_open_btn_in_desktop_plugs_by_ui()</span></span></code></pre></div><h2 id="应用启动" tabindex="-1">应用启动 <a class="header-anchor" href="#应用启动" aria-label="Permalink to &quot;应用启动&quot;">​</a></h2><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># mikigo</span></span></code></pre></div><p>在UI自动化测试中，一切操作的都是从应用启动开始的，而在Linux桌面应用自动化测试中，我们启动应用的方法有多种，下面做一个简单的介绍：</p><p><strong>【使用dogtail启动】</strong></p><p>dogtail提供了应用启动的方法，在utils库中，使用run方法启动：</p><p>首先导入方法：</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dogtail.utils </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span></span></code></pre></div><p>调用run方法</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">run(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;deepin-music&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>即可启动音乐 <img src="https://img2020.cnblogs.com/blog/1898113/202012/1898113-20201218162414410-1539488857.png" alt="img"></p><p>这种方法的优点是采用进程的方式直接启动，不依赖与UI，无论桌面或任务栏上是否存在应用图标，都可以正常启动。</p><p>但是在实际项目中，仍然存在一个问题，</p><p>如果使用ssh远程调用，或者 Jenkins 中执行测试脚本的时候，在 sniff 中会出现找不到应用，经过分析，可能是因为使用这种方法启动的时候，实际是采用一个子进程启动了应用，dogtail 无法识别到。</p><p><strong>【从任务栏启动】</strong></p><p>使用dogtail点击任务栏上的应用图标</p><p>通常有两种方法：</p><p>（1）使用dogtail点击任务栏上的应用图标。</p><p>（2）已知应用图标在任务栏上的位置，然后使用鼠标点击对应坐标。</p><p>第二种方法的缺点是位置必须固定，如果移动位置就不行了，而使用第一种方法，无论位置在哪里，只要图标在任务栏上存在即可。</p><p><strong>【点击桌面图标启动】</strong></p><p>桌面图标目前是采用图像识别技术，定位到应用图标的坐标，然后通过pyauogui进行点击操作。</p><p>详细技术方案可以参考我的另外两篇博客:</p><p><a href="https://www.cnblogs.com/mikigo/p/13489143.html" target="_blank" rel="noreferrer">基于opencv的模板匹配实现图像识别，返回在屏幕中的坐标</a></p><p><a href="https://www.cnblogs.com/mikigo/p/13182619.html" target="_blank" rel="noreferrer">Python三方库PyAutoGui的使用方法</a></p><p><strong>【从启动器启动（俗称开始菜单）】</strong></p><p>启动中启动的实现逻辑实际和任务栏上启动差不多。</p><p>首先，需要使用鼠标点击任务栏上的启动器图标，或者键盘super键，将启动器呼出来，</p><p>然后，在启动器中点击对应的图标，</p><p>但是这里有个问题，启动器中的应用列表，一页展示不完，所以如果我们要点击的应用图标不在第一页怎么办，通常解决方案有两种：</p><p>（1）需要进行向下滑动，这里就涉及到相应的识别方案，判断如果不在第一页就往下滑动翻页。</p><p>（2）启动器提供搜索的功能，输入应用名称搜索，然后进行点击。</p><p>从实际操作中来看，采用第二种方法的效率会高一点。</p><p><strong>【终端命令启动】</strong></p><p>在 Python 中，使用 <code>os.popen()</code> 或 <code>os.system()</code> 或 <code>subprocess.Popen()</code>，实现命令行启动，比如：</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> os</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">os.popen(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;deepin-music&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>这种方式启动是比较简单的，但是在实际项目中，仍然存在远程执行脚本的时候，dogtail 无法识别的问题。</p><p><strong>【总结】</strong></p><p>以上几种方法，各有优缺点，在实际项目中：</p><p>（1）如果需要在 Jenkins 中做持续集成，建议使用第二种任务栏启动的方法。</p><p>（2）如果不会采用远程执行的，建议采用第一种或者最后一种方案。</p><p>（3）第三种和第四种启动方法，通常在测试用例中会涉及到，所以偶尔会用。</p><h2 id="其他不为人知的细节" tabindex="-1">其他不为人知的细节 <a class="header-anchor" href="#其他不为人知的细节" aria-label="Permalink to &quot;其他不为人知的细节&quot;">​</a></h2><ul><li>在一段时间内尽量编写同一个应用或模块的用例，能对该用例已有方法熟悉，避免过多重复业务代码的封装；</li><li>相同的场景下，各架构等待时间不同，建议使用框架提供的 sleep，我们做了不同架构的倍数放大；</li><li>编写用例时，尽量考虑到每一步异常后的环境恢复，需要建议这种意识，随时要考虑到，这步操作有没有可能出错，出错了改怎么办；</li><li>提交代码的时候注意不要把一些临时的测试资源提交进去了，比如测试了一个影片，有些同学习惯使用 <code>git add .</code> ，然后就全部提交到代码仓库了，这样即使后期把大文件删了，<code>.git</code> 文件里面也会很大，造成代码仓库变得十分臃肿。</li></ul>`,96)]))}const g=i(e,[["render",p]]);export{c as __pageData,g as default};
